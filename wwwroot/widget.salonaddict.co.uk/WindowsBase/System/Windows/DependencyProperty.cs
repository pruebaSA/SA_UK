namespace System.Windows
{
    using MS.Internal;
    using MS.Internal.WindowsBase;
    using MS.Utility;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Threading;
    using System.Windows.Markup;
    using System.Windows.Threading;

    [TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null"), ValueSerializer(typeof(DependencyPropertyValueSerializer))]
    public sealed class DependencyProperty
    {
        private PropertyMetadata _defaultMetadata;
        private CoerceValueCallback _designerCoerceValueCallback;
        internal InsertionSortMap _metadataMap;
        private string _name;
        private Type _ownerType;
        private Flags _packedData;
        private Type _propertyType;
        private DependencyPropertyKey _readOnlyKey;
        private System.Windows.ValidateValueCallback _validateValueCallback;
        private static int GlobalIndexCount;
        private static Type NullableType = typeof(Nullable<>);
        private static Hashtable PropertyFromName = new Hashtable();
        internal static ItemStructList<DependencyProperty> RegisteredPropertyList = new ItemStructList<DependencyProperty>(0x300);
        internal static object Synchronized = new object();
        public static readonly object UnsetValue = new NamedObject("DependencyProperty.UnsetValue");

        private DependencyProperty(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback)
        {
            Flags uniqueGlobalIndex;
            this._metadataMap = new InsertionSortMap();
            this._name = name;
            this._propertyType = propertyType;
            this._ownerType = ownerType;
            this._defaultMetadata = defaultMetadata;
            this._validateValueCallback = validateValueCallback;
            lock (Synchronized)
            {
                uniqueGlobalIndex = (Flags) GetUniqueGlobalIndex(ownerType, name);
                RegisteredPropertyList.Add(this);
            }
            if (propertyType.IsValueType)
            {
                uniqueGlobalIndex |= Flags.IsValueType;
            }
            if (propertyType == typeof(object))
            {
                uniqueGlobalIndex |= Flags.IsObjectType;
            }
            if (typeof(Freezable).IsAssignableFrom(propertyType))
            {
                uniqueGlobalIndex |= Flags.IsFreezableType;
            }
            if (propertyType == typeof(string))
            {
                uniqueGlobalIndex |= Flags.IsStringType;
            }
            this._packedData = uniqueGlobalIndex;
        }

        public DependencyProperty AddOwner(Type ownerType) => 
            this.AddOwner(ownerType, null);

        public DependencyProperty AddOwner(Type ownerType, PropertyMetadata typeMetadata)
        {
            if (ownerType == null)
            {
                throw new ArgumentNullException("ownerType");
            }
            FromNameKey key = new FromNameKey(this.Name, ownerType);
            lock (Synchronized)
            {
                if (PropertyFromName.Contains(key))
                {
                    throw new ArgumentException(System.Windows.SR.Get("PropertyAlreadyRegistered", new object[] { this.Name, ownerType.Name }));
                }
            }
            if (typeMetadata != null)
            {
                this.OverrideMetadata(ownerType, typeMetadata);
            }
            lock (Synchronized)
            {
                PropertyFromName[key] = this;
            }
            return this;
        }

        private static object AutoGenerateDefaultValue(Type propertyType)
        {
            object obj2 = null;
            if (propertyType.IsValueType)
            {
                obj2 = Activator.CreateInstance(propertyType);
            }
            return obj2;
        }

        private static PropertyMetadata AutoGeneratePropertyMetadata(Type propertyType, System.Windows.ValidateValueCallback validateValueCallback, string name, Type ownerType)
        {
            object obj2 = AutoGenerateDefaultValue(propertyType);
            if ((validateValueCallback != null) && !validateValueCallback(obj2))
            {
                throw new ArgumentException(System.Windows.SR.Get("DefaultValueAutoAssignFailed", new object[] { name, ownerType.Name }));
            }
            return new PropertyMetadata(obj2);
        }

        [FriendAccessAllowed]
        internal static DependencyProperty FromName(string name, Type ownerType)
        {
            DependencyProperty property = null;
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (ownerType == null)
            {
                throw new ArgumentNullException("ownerType");
            }
            FromNameKey key = new FromNameKey(name, ownerType);
            while ((property == null) && (ownerType != null))
            {
                RuntimeHelpers.RunClassConstructor(ownerType.TypeHandle);
                key.UpdateNameKey(ownerType);
                lock (Synchronized)
                {
                    property = (DependencyProperty) PropertyFromName[key];
                }
                ownerType = ownerType.BaseType;
            }
            return property;
        }

        [FriendAccessAllowed]
        internal object GetDefaultValue(Type forType)
        {
            if (!this.IsDefaultValueChanged)
            {
                return this.DefaultMetadata.DefaultValue;
            }
            return this.GetMetadata(DependencyObjectType.FromSystemTypeInternal(forType)).DefaultValue;
        }

        [FriendAccessAllowed]
        internal object GetDefaultValue(DependencyObjectType dependencyObjectType)
        {
            if (!this.IsDefaultValueChanged)
            {
                return this.DefaultMetadata.DefaultValue;
            }
            return this.GetMetadata(dependencyObjectType).DefaultValue;
        }

        public override int GetHashCode() => 
            this.GlobalIndex;

        public PropertyMetadata GetMetadata(Type forType)
        {
            if (forType == null)
            {
                throw new ArgumentNullException("forType");
            }
            return this.GetMetadata(DependencyObjectType.FromSystemType(forType));
        }

        public PropertyMetadata GetMetadata(DependencyObject dependencyObject)
        {
            if (dependencyObject == null)
            {
                throw new ArgumentNullException("dependencyObject");
            }
            return this.GetMetadata(dependencyObject.DependencyObjectType);
        }

        public PropertyMetadata GetMetadata(DependencyObjectType dependencyObjectType)
        {
            if (dependencyObjectType != null)
            {
                int num2;
                object obj2;
                int index = this._metadataMap.Count - 1;
                if (index < 0)
                {
                    return this._defaultMetadata;
                }
                if (index == 0)
                {
                    this._metadataMap.GetKeyValuePair(index, out num2, out obj2);
                    while (dependencyObjectType.Id > num2)
                    {
                        dependencyObjectType = dependencyObjectType.BaseType;
                    }
                    if (num2 == dependencyObjectType.Id)
                    {
                        return (PropertyMetadata) obj2;
                    }
                }
                else if (dependencyObjectType.Id != 0)
                {
                    do
                    {
                        this._metadataMap.GetKeyValuePair(index, out num2, out obj2);
                        index--;
                        while ((dependencyObjectType.Id < num2) && (index >= 0))
                        {
                            this._metadataMap.GetKeyValuePair(index, out num2, out obj2);
                            index--;
                        }
                        while (dependencyObjectType.Id > num2)
                        {
                            dependencyObjectType = dependencyObjectType.BaseType;
                        }
                        if (num2 == dependencyObjectType.Id)
                        {
                            return (PropertyMetadata) obj2;
                        }
                    }
                    while (index >= 0);
                }
            }
            return this._defaultMetadata;
        }

        internal static int GetUniqueGlobalIndex(Type ownerType, string name)
        {
            if (GlobalIndexCount < 0xffff)
            {
                return GlobalIndexCount++;
            }
            if (ownerType != null)
            {
                throw new InvalidOperationException(System.Windows.SR.Get("TooManyDependencyProperties", new object[] { ownerType.Name + "." + name }));
            }
            throw new InvalidOperationException(System.Windows.SR.Get("TooManyDependencyProperties", new object[] { "ConstantProperty" }));
        }

        public bool IsValidType(object value) => 
            IsValidType(value, this.PropertyType);

        internal static bool IsValidType(object value, Type propertyType)
        {
            if (value == null)
            {
                if (propertyType.IsValueType && (!propertyType.IsGenericType || (propertyType.GetGenericTypeDefinition() != NullableType)))
                {
                    return false;
                }
            }
            else if (!propertyType.IsInstanceOfType(value))
            {
                return false;
            }
            return true;
        }

        public bool IsValidValue(object value)
        {
            if (!IsValidType(value, this.PropertyType))
            {
                return false;
            }
            if (this.ValidateValueCallback != null)
            {
                return this.ValidateValueCallback(value);
            }
            return true;
        }

        internal bool IsValidValueInternal(object value)
        {
            if (this.ValidateValueCallback != null)
            {
                return this.ValidateValueCallback(value);
            }
            return true;
        }

        public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata)
        {
            DependencyObjectType type;
            PropertyMetadata metadata;
            this.SetupOverrideMetadata(forType, typeMetadata, out type, out metadata);
            if (this.ReadOnly)
            {
                throw new InvalidOperationException(System.Windows.SR.Get("ReadOnlyOverrideNotAllowed", new object[] { this.Name }));
            }
            this.ProcessOverrideMetadata(forType, typeMetadata, type, metadata);
        }

        public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyPropertyKey key)
        {
            DependencyObjectType type;
            PropertyMetadata metadata;
            this.SetupOverrideMetadata(forType, typeMetadata, out type, out metadata);
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }
            if (!this.ReadOnly)
            {
                throw new InvalidOperationException(System.Windows.SR.Get("PropertyNotReadOnly"));
            }
            if (key.DependencyProperty != this)
            {
                throw new ArgumentException(System.Windows.SR.Get("ReadOnlyOverrideKeyNotAuthorized", new object[] { this.Name }));
            }
            this.VerifyReadOnlyKey(key);
            this.ProcessOverrideMetadata(forType, typeMetadata, type, metadata);
        }

        private void ProcessOverrideMetadata(Type forType, PropertyMetadata typeMetadata, DependencyObjectType dType, PropertyMetadata baseMetadata)
        {
            lock (Synchronized)
            {
                if (UnsetValue != this._metadataMap[dType.Id])
                {
                    throw new ArgumentException(System.Windows.SR.Get("TypeMetadataAlreadyRegistered", new object[] { forType.Name }));
                }
                this._metadataMap[dType.Id] = typeMetadata;
            }
            typeMetadata.InvokeMerge(baseMetadata, this);
            typeMetadata.Seal(this, forType);
            if (typeMetadata.IsInherited)
            {
                this._packedData |= Flags.IsPotentiallyInherited;
            }
            if (typeMetadata.DefaultValueWasSet() && (typeMetadata.DefaultValue != this.DefaultMetadata.DefaultValue))
            {
                this._packedData |= Flags.IsDefaultValueChanged;
            }
            if (typeMetadata.UsingDefaultValueFactory)
            {
                this._packedData |= Flags.IsPotentiallyUsingDefaultValueFactory;
            }
        }

        public static DependencyProperty Register(string name, Type propertyType, Type ownerType) => 
            Register(name, propertyType, ownerType, null, null);

        public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata) => 
            Register(name, propertyType, ownerType, typeMetadata, null);

        public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback)
        {
            RegisterParameterValidation(name, propertyType, ownerType);
            PropertyMetadata defaultMetadata = null;
            if ((typeMetadata != null) && typeMetadata.DefaultValueWasSet())
            {
                defaultMetadata = new PropertyMetadata(typeMetadata.DefaultValue);
            }
            DependencyProperty property = RegisterCommon(name, propertyType, ownerType, defaultMetadata, validateValueCallback);
            if (typeMetadata != null)
            {
                property.OverrideMetadata(ownerType, typeMetadata);
            }
            return property;
        }

        public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType) => 
            RegisterAttached(name, propertyType, ownerType, null, null);

        public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata) => 
            RegisterAttached(name, propertyType, ownerType, defaultMetadata, null);

        public static DependencyProperty RegisterAttached(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback)
        {
            RegisterParameterValidation(name, propertyType, ownerType);
            return RegisterCommon(name, propertyType, ownerType, defaultMetadata, validateValueCallback);
        }

        public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata) => 
            RegisterAttachedReadOnly(name, propertyType, ownerType, defaultMetadata, null);

        public static DependencyPropertyKey RegisterAttachedReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback)
        {
            RegisterParameterValidation(name, propertyType, ownerType);
            if (defaultMetadata == null)
            {
                defaultMetadata = AutoGeneratePropertyMetadata(propertyType, validateValueCallback, name, ownerType);
            }
            DependencyPropertyKey key = new DependencyPropertyKey(null);
            DependencyProperty dp = RegisterCommon(name, propertyType, ownerType, defaultMetadata, validateValueCallback);
            dp._readOnlyKey = key;
            key.SetDependencyProperty(dp);
            return key;
        }

        private static DependencyProperty RegisterCommon(string name, Type propertyType, Type ownerType, PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback)
        {
            FromNameKey key = new FromNameKey(name, ownerType);
            lock (Synchronized)
            {
                if (PropertyFromName.Contains(key))
                {
                    throw new ArgumentException(System.Windows.SR.Get("PropertyAlreadyRegistered", new object[] { name, ownerType.Name }));
                }
            }
            if (defaultMetadata == null)
            {
                defaultMetadata = AutoGeneratePropertyMetadata(propertyType, validateValueCallback, name, ownerType);
            }
            else
            {
                if (!defaultMetadata.DefaultValueWasSet())
                {
                    defaultMetadata.DefaultValue = AutoGenerateDefaultValue(propertyType);
                }
                ValidateMetadataDefaultValue(defaultMetadata, propertyType, name, validateValueCallback);
            }
            DependencyProperty dp = new DependencyProperty(name, propertyType, ownerType, defaultMetadata, validateValueCallback);
            defaultMetadata.Seal(dp, null);
            if (defaultMetadata.IsInherited)
            {
                dp._packedData |= Flags.IsPotentiallyInherited;
            }
            if (defaultMetadata.UsingDefaultValueFactory)
            {
                dp._packedData |= Flags.IsPotentiallyUsingDefaultValueFactory;
            }
            lock (Synchronized)
            {
                PropertyFromName[key] = dp;
            }
            if (TraceDependencyProperty.IsEnabled)
            {
                TraceDependencyProperty.TraceActivityItem(TraceDependencyProperty.Register, dp, dp.OwnerType);
            }
            return dp;
        }

        private static void RegisterParameterValidation(string name, Type propertyType, Type ownerType)
        {
            if (name == null)
            {
                throw new ArgumentNullException("name");
            }
            if (name.Length == 0)
            {
                throw new ArgumentException(System.Windows.SR.Get("StringEmpty"), "name");
            }
            if (ownerType == null)
            {
                throw new ArgumentNullException("ownerType");
            }
            if (propertyType == null)
            {
                throw new ArgumentNullException("propertyType");
            }
        }

        public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata) => 
            RegisterReadOnly(name, propertyType, ownerType, typeMetadata, null);

        public static DependencyPropertyKey RegisterReadOnly(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback)
        {
            RegisterParameterValidation(name, propertyType, ownerType);
            PropertyMetadata defaultMetadata = null;
            if ((typeMetadata != null) && typeMetadata.DefaultValueWasSet())
            {
                defaultMetadata = new PropertyMetadata(typeMetadata.DefaultValue);
            }
            else
            {
                defaultMetadata = AutoGeneratePropertyMetadata(propertyType, validateValueCallback, name, ownerType);
            }
            DependencyPropertyKey key = new DependencyPropertyKey(null);
            DependencyProperty dp = RegisterCommon(name, propertyType, ownerType, defaultMetadata, validateValueCallback);
            dp._readOnlyKey = key;
            key.SetDependencyProperty(dp);
            if (typeMetadata == null)
            {
                typeMetadata = AutoGeneratePropertyMetadata(propertyType, validateValueCallback, name, ownerType);
            }
            dp.OverrideMetadata(ownerType, typeMetadata, key);
            return key;
        }

        private void SetupOverrideMetadata(Type forType, PropertyMetadata typeMetadata, out DependencyObjectType dType, out PropertyMetadata baseMetadata)
        {
            if (forType == null)
            {
                throw new ArgumentNullException("forType");
            }
            if (typeMetadata == null)
            {
                throw new ArgumentNullException("typeMetadata");
            }
            if (typeMetadata.Sealed)
            {
                throw new ArgumentException(System.Windows.SR.Get("TypeMetadataAlreadyInUse"));
            }
            if (!typeof(DependencyObject).IsAssignableFrom(forType))
            {
                throw new ArgumentException(System.Windows.SR.Get("TypeMustBeDependencyObjectDerived", new object[] { forType.Name }));
            }
            if (typeMetadata.IsDefaultValueModified)
            {
                ValidateMetadataDefaultValue(typeMetadata, this.PropertyType, this.Name, this.ValidateValueCallback);
            }
            dType = DependencyObjectType.FromSystemType(forType);
            baseMetadata = this.GetMetadata(dType.BaseType);
            if (!baseMetadata.GetType().IsAssignableFrom(typeMetadata.GetType()))
            {
                throw new ArgumentException(System.Windows.SR.Get("OverridingMetadataDoesNotMatchBaseMetadataType"));
            }
        }

        public override string ToString() => 
            this._name;

        private static void ValidateDefaultValueCommon(object defaultValue, Type propertyType, string propertyName, System.Windows.ValidateValueCallback validateValueCallback, bool checkThreadAffinity)
        {
            if (!IsValidType(defaultValue, propertyType))
            {
                throw new ArgumentException(System.Windows.SR.Get("DefaultValuePropertyTypeMismatch", new object[] { propertyName }));
            }
            if (defaultValue is Expression)
            {
                throw new ArgumentException(System.Windows.SR.Get("DefaultValueMayNotBeExpression"));
            }
            if (checkThreadAffinity)
            {
                DispatcherObject obj2 = defaultValue as DispatcherObject;
                if ((obj2 != null) && (obj2.Dispatcher != null))
                {
                    ISealable sealable = obj2 as ISealable;
                    if ((sealable == null) || !sealable.CanSeal)
                    {
                        throw new ArgumentException(System.Windows.SR.Get("DefaultValueMustBeFreeThreaded", new object[] { propertyName }));
                    }
                    Invariant.Assert(!sealable.IsSealed, "A Sealed ISealable must not have dispatcher affinity");
                    sealable.Seal();
                    Invariant.Assert(obj2.Dispatcher == null, "ISealable.Seal() failed after ISealable.CanSeal returned true");
                }
            }
            if ((validateValueCallback != null) && !validateValueCallback(defaultValue))
            {
                throw new ArgumentException(System.Windows.SR.Get("DefaultValueInvalid", new object[] { propertyName }));
            }
        }

        internal void ValidateFactoryDefaultValue(object defaultValue)
        {
            ValidateDefaultValueCommon(defaultValue, this.PropertyType, this.Name, this.ValidateValueCallback, false);
        }

        private static void ValidateMetadataDefaultValue(PropertyMetadata defaultMetadata, Type propertyType, string propertyName, System.Windows.ValidateValueCallback validateValueCallback)
        {
            if (!defaultMetadata.UsingDefaultValueFactory)
            {
                ValidateDefaultValueCommon(defaultMetadata.DefaultValue, propertyType, propertyName, validateValueCallback, true);
            }
        }

        internal void VerifyReadOnlyKey(DependencyPropertyKey candidateKey)
        {
            if (this._readOnlyKey != candidateKey)
            {
                throw new ArgumentException(System.Windows.SR.Get("ReadOnlyKeyNotAuthorized"));
            }
        }

        public PropertyMetadata DefaultMetadata =>
            this._defaultMetadata;

        internal CoerceValueCallback DesignerCoerceValueCallback
        {
            get => 
                this._designerCoerceValueCallback;
            set
            {
                if (this.ReadOnly)
                {
                    throw new InvalidOperationException(System.Windows.SR.Get("ReadOnlyDesignerCoersionNotAllowed", new object[] { this.Name }));
                }
                this._designerCoerceValueCallback = value;
            }
        }

        public int GlobalIndex =>
            (((int) this._packedData) & 0xffff);

        internal bool IsDefaultValueChanged =>
            ((this._packedData & Flags.IsDefaultValueChanged) != 0);

        internal bool IsFreezableType =>
            ((this._packedData & Flags.IsFreezableType) != 0);

        internal bool IsObjectType =>
            ((this._packedData & Flags.IsObjectType) != 0);

        internal bool IsPotentiallyInherited =>
            ((this._packedData & Flags.IsPotentiallyInherited) != 0);

        internal bool IsPotentiallyUsingDefaultValueFactory =>
            ((this._packedData & Flags.IsPotentiallyUsingDefaultValueFactory) != 0);

        internal bool IsStringType =>
            ((this._packedData & Flags.IsStringType) != 0);

        internal bool IsValueType =>
            ((this._packedData & Flags.IsValueType) != 0);

        public string Name =>
            this._name;

        public Type OwnerType =>
            this._ownerType;

        public Type PropertyType =>
            this._propertyType;

        public bool ReadOnly =>
            (this._readOnlyKey != null);

        internal static IEnumerable RegisteredProperties =>
            new RegisteredPropertiesEnumerable(-2);

        internal static int RegisteredPropertyCount =>
            RegisteredPropertyList.Count;

        public System.Windows.ValidateValueCallback ValidateValueCallback =>
            this._validateValueCallback;

        [Flags]
        private enum Flags
        {
            GlobalIndexMask = 0xffff,
            IsDefaultValueChanged = 0x100000,
            IsFreezableType = 0x20000,
            IsObjectType = 0x400000,
            IsPotentiallyInherited = 0x80000,
            IsPotentiallyUsingDefaultValueFactory = 0x200000,
            IsStringType = 0x40000,
            IsValueType = 0x10000
        }

        private class FromNameKey
        {
            private int _hashCode;
            private string _name;
            private Type _ownerType;

            public FromNameKey(string name, Type ownerType)
            {
                this._name = name;
                this._ownerType = ownerType;
                this._hashCode = this._name.GetHashCode() ^ this._ownerType.GetHashCode();
            }

            public override bool Equals(object o) => 
                (((o != null) && (o is DependencyProperty.FromNameKey)) && this.Equals((DependencyProperty.FromNameKey) o));

            public bool Equals(DependencyProperty.FromNameKey key) => 
                (this._name.Equals(key._name) && (this._ownerType == key._ownerType));

            public override int GetHashCode() => 
                this._hashCode;

            public void UpdateNameKey(Type ownerType)
            {
                this._ownerType = ownerType;
                this._hashCode = this._name.GetHashCode() ^ this._ownerType.GetHashCode();
            }
        }

        private sealed class RegisteredPropertiesEnumerable : IEnumerable<object>, IEnumerable, IEnumerator<object>, IEnumerator, IDisposable
        {
            private object _current;
            private int _index;
            private DependencyProperty[] _propertyList;
            private int _state;
            private int _threadId;

            public RegisteredPropertiesEnumerable(int state)
            {
                this._state = state;
                this._threadId = Thread.CurrentThread.ManagedThreadId;
            }

            private void Finally2()
            {
                this._state = -1;
            }

            public bool MoveNext()
            {
                bool flag2;
                bool flag = true;
                try
                {
                    DependencyProperty property;
                    switch (this._state)
                    {
                        case 0:
                            this._state = 1;
                            this._propertyList = DependencyProperty.RegisteredPropertyList.List;
                            this._index = 0;
                            goto Label_008D;

                        case 2:
                            this._state = 1;
                            this._index++;
                            goto Label_008D;

                        default:
                            flag = false;
                            return false;
                    }
                Label_005A:
                    property = this._propertyList[this._index];
                    if (property != null)
                    {
                        this._current = property;
                        this._state = 2;
                        flag = false;
                        return true;
                    }
                    this._index++;
                Label_008D:
                    if (this._index < this._propertyList.Length)
                    {
                        goto Label_005A;
                    }
                    this.Finally2();
                    flag = false;
                    flag2 = false;
                }
                finally
                {
                    if (flag)
                    {
                        ((IDisposable) this).Dispose();
                    }
                }
                return flag2;
            }

            IEnumerator<object> IEnumerable<object>.GetEnumerator()
            {
                if ((Thread.CurrentThread.ManagedThreadId == this._threadId) && (this._state == -2))
                {
                    this._state = 0;
                    return this;
                }
                return new DependencyProperty.RegisteredPropertiesEnumerable(0);
            }

            IEnumerator IEnumerable.GetEnumerator() => 
                ((IEnumerable<object>) this).GetEnumerator();

            void IEnumerator.Reset()
            {
                throw new NotSupportedException();
            }

            void IDisposable.Dispose()
            {
                switch (this._state)
                {
                    case 1:
                    case 2:
                        this.Finally2();
                        return;
                }
            }

            object IEnumerator<object>.Current =>
                this._current;

            object IEnumerator.Current =>
                this._current;
        }
    }
}

