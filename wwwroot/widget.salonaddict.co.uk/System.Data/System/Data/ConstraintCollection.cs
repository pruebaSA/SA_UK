namespace System.Data
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data.Common;
    using System.Globalization;
    using System.Reflection;

    [Editor("Microsoft.VSDesigner.Data.Design.ConstraintsCollectionEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"), DefaultEvent("CollectionChanged")]
    public sealed class ConstraintCollection : InternalDataCollectionBase
    {
        private int defaultNameIndex = 1;
        private Constraint[] delayLoadingConstraints;
        private bool fLoadForeignKeyConstraintsOnly;
        private readonly ArrayList list = new ArrayList();
        private readonly DataTable table;

        public event CollectionChangeEventHandler CollectionChanged;

        internal ConstraintCollection(DataTable table)
        {
            this.table = table;
        }

        public void Add(Constraint constraint)
        {
            this.Add(constraint, true);
        }

        internal void Add(Constraint constraint, bool addUniqueWhenAddingForeign)
        {
            if (constraint == null)
            {
                throw ExceptionBuilder.ArgumentNull("constraint");
            }
            if (this.FindConstraint(constraint) != null)
            {
                throw ExceptionBuilder.DuplicateConstraint(this.FindConstraint(constraint).ConstraintName);
            }
            if ((1 < this.table.NestedParentRelations.Length) && !this.AutoGenerated(constraint))
            {
                throw ExceptionBuilder.CantAddConstraintToMultipleNestedTable(this.table.TableName);
            }
            if (constraint is UniqueConstraint)
            {
                if (((UniqueConstraint) constraint).bPrimaryKey && (this.Table.primaryKey != null))
                {
                    throw ExceptionBuilder.AddPrimaryKeyConstraint();
                }
                this.AddUniqueConstraint((UniqueConstraint) constraint);
            }
            else if (constraint is ForeignKeyConstraint)
            {
                ForeignKeyConstraint constraint2 = (ForeignKeyConstraint) constraint;
                if (addUniqueWhenAddingForeign && (constraint2.RelatedTable.Constraints.FindKeyConstraint(constraint2.RelatedColumnsReference) == null))
                {
                    if (constraint.ConstraintName.Length == 0)
                    {
                        constraint.ConstraintName = this.AssignName();
                    }
                    else
                    {
                        this.RegisterName(constraint.ConstraintName);
                    }
                    UniqueConstraint constraint3 = new UniqueConstraint(constraint2.RelatedColumnsReference);
                    constraint2.RelatedTable.Constraints.Add(constraint3);
                }
                this.AddForeignKeyConstraint((ForeignKeyConstraint) constraint);
            }
            this.BaseAdd(constraint);
            this.ArrayAdd(constraint);
            this.OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, constraint));
            if ((constraint is UniqueConstraint) && ((UniqueConstraint) constraint).bPrimaryKey)
            {
                this.Table.PrimaryKey = ((UniqueConstraint) constraint).ColumnsReference;
            }
        }

        public Constraint Add(string name, DataColumn[] columns, bool primaryKey)
        {
            UniqueConstraint constraint = new UniqueConstraint(name, columns);
            this.Add(constraint);
            if (primaryKey)
            {
                this.Table.PrimaryKey = columns;
            }
            return constraint;
        }

        public Constraint Add(string name, DataColumn column, bool primaryKey)
        {
            UniqueConstraint constraint = new UniqueConstraint(name, column);
            this.Add(constraint);
            if (primaryKey)
            {
                this.Table.PrimaryKey = constraint.ColumnsReference;
            }
            return constraint;
        }

        public Constraint Add(string name, DataColumn primaryKeyColumn, DataColumn foreignKeyColumn)
        {
            ForeignKeyConstraint constraint = new ForeignKeyConstraint(name, primaryKeyColumn, foreignKeyColumn);
            this.Add(constraint);
            return constraint;
        }

        public Constraint Add(string name, DataColumn[] primaryKeyColumns, DataColumn[] foreignKeyColumns)
        {
            ForeignKeyConstraint constraint = new ForeignKeyConstraint(name, primaryKeyColumns, foreignKeyColumns);
            this.Add(constraint);
            return constraint;
        }

        private void AddForeignKeyConstraint(ForeignKeyConstraint constraint)
        {
            if (!constraint.CanEnableConstraint())
            {
                throw ExceptionBuilder.ConstraintParentValues();
            }
            constraint.CheckCanAddToCollection(this);
        }

        public void AddRange(Constraint[] constraints)
        {
            if (this.table.fInitInProgress)
            {
                this.delayLoadingConstraints = constraints;
                this.fLoadForeignKeyConstraintsOnly = false;
            }
            else if (constraints != null)
            {
                foreach (Constraint constraint in constraints)
                {
                    if (constraint != null)
                    {
                        this.Add(constraint);
                    }
                }
            }
        }

        private void AddUniqueConstraint(UniqueConstraint constraint)
        {
            DataColumn[] columnsReference = constraint.ColumnsReference;
            for (int i = 0; i < columnsReference.Length; i++)
            {
                if (columnsReference[i].Table != this.table)
                {
                    throw ExceptionBuilder.ConstraintForeignTable();
                }
            }
            constraint.ConstraintIndexInitialize();
            if (!constraint.CanEnableConstraint())
            {
                constraint.ConstraintIndexClear();
                throw ExceptionBuilder.UniqueConstraintViolation();
            }
        }

        private void ArrayAdd(Constraint constraint)
        {
            this.List.Add(constraint);
        }

        private void ArrayRemove(Constraint constraint)
        {
            this.List.Remove(constraint);
        }

        internal string AssignName()
        {
            string str = this.MakeName(this.defaultNameIndex);
            this.defaultNameIndex++;
            return str;
        }

        private bool AutoGenerated(Constraint constraint)
        {
            ForeignKeyConstraint fk = constraint as ForeignKeyConstraint;
            if (fk != null)
            {
                return XmlTreeGen.AutoGenerated(fk, false);
            }
            UniqueConstraint unique = (UniqueConstraint) constraint;
            return XmlTreeGen.AutoGenerated(unique);
        }

        private void BaseAdd(Constraint constraint)
        {
            if (constraint == null)
            {
                throw ExceptionBuilder.ArgumentNull("constraint");
            }
            if (constraint.ConstraintName.Length == 0)
            {
                constraint.ConstraintName = this.AssignName();
            }
            else
            {
                this.RegisterName(constraint.ConstraintName);
            }
            constraint.InCollection = true;
        }

        private void BaseGroupSwitch(Constraint[] oldArray, int oldLength, Constraint[] newArray, int newLength)
        {
            int num4 = 0;
            for (int i = 0; i < oldLength; i++)
            {
                bool flag = false;
                for (int k = num4; k < newLength; k++)
                {
                    if (oldArray[i] == newArray[k])
                    {
                        if (num4 == k)
                        {
                            num4++;
                        }
                        flag = true;
                        break;
                    }
                }
                if (!flag)
                {
                    this.BaseRemove(oldArray[i]);
                    this.List.Remove(oldArray[i]);
                }
            }
            for (int j = 0; j < newLength; j++)
            {
                if (!newArray[j].InCollection)
                {
                    this.BaseAdd(newArray[j]);
                }
                this.List.Add(newArray[j]);
            }
        }

        private void BaseRemove(Constraint constraint)
        {
            if (constraint == null)
            {
                throw ExceptionBuilder.ArgumentNull("constraint");
            }
            if (constraint.Table != this.table)
            {
                throw ExceptionBuilder.ConstraintRemoveFailed();
            }
            this.UnregisterName(constraint.ConstraintName);
            constraint.InCollection = false;
            if (constraint is UniqueConstraint)
            {
                for (int i = 0; i < this.Table.ChildRelations.Count; i++)
                {
                    DataRelation relation2 = this.Table.ChildRelations[i];
                    if (relation2.ParentKeyConstraint == constraint)
                    {
                        relation2.SetParentKeyConstraint(null);
                    }
                }
                ((UniqueConstraint) constraint).ConstraintIndexClear();
            }
            else if (constraint is ForeignKeyConstraint)
            {
                for (int j = 0; j < this.Table.ParentRelations.Count; j++)
                {
                    DataRelation relation = this.Table.ParentRelations[j];
                    if (relation.ChildKeyConstraint == constraint)
                    {
                        relation.SetChildKeyConstraint(null);
                    }
                }
            }
        }

        public bool CanRemove(Constraint constraint) => 
            this.CanRemove(constraint, false);

        internal bool CanRemove(Constraint constraint, bool fThrowException) => 
            constraint.CanBeRemovedFromCollection(this, fThrowException);

        public void Clear()
        {
            if (this.table != null)
            {
                this.table.PrimaryKey = null;
                for (int i = 0; i < this.table.ParentRelations.Count; i++)
                {
                    this.table.ParentRelations[i].SetChildKeyConstraint(null);
                }
                for (int j = 0; j < this.table.ChildRelations.Count; j++)
                {
                    this.table.ChildRelations[j].SetParentKeyConstraint(null);
                }
            }
            if (this.table.fInitInProgress && (this.delayLoadingConstraints != null))
            {
                this.delayLoadingConstraints = null;
                this.fLoadForeignKeyConstraintsOnly = false;
            }
            int count = this.List.Count;
            Constraint[] array = new Constraint[this.List.Count];
            this.List.CopyTo(array, 0);
            try
            {
                this.BaseGroupSwitch(array, count, null, 0);
            }
            catch (Exception exception)
            {
                if (ADP.IsCatchableOrSecurityExceptionType(exception))
                {
                    this.BaseGroupSwitch(null, 0, array, count);
                    this.List.Clear();
                    for (int k = 0; k < count; k++)
                    {
                        this.List.Add(array[k]);
                    }
                }
                throw;
            }
            this.List.Clear();
            this.OnCollectionChanged(InternalDataCollectionBase.RefreshEventArgs);
        }

        private static bool CompareArrays(DataColumn[] a1, DataColumn[] a2)
        {
            if (a1.Length != a2.Length)
            {
                return false;
            }
            for (int i = 0; i < a1.Length; i++)
            {
                bool flag = false;
                for (int j = 0; j < a2.Length; j++)
                {
                    if (a1[i] == a2[j])
                    {
                        flag = true;
                        break;
                    }
                }
                if (!flag)
                {
                    return false;
                }
            }
            return true;
        }

        public bool Contains(string name) => 
            (this.InternalIndexOf(name) >= 0);

        internal bool Contains(string name, bool caseSensitive)
        {
            if (!caseSensitive)
            {
                return this.Contains(name);
            }
            int num = this.InternalIndexOf(name);
            if (num < 0)
            {
                return false;
            }
            return (name == ((Constraint) this.List[num]).ConstraintName);
        }

        public void CopyTo(Constraint[] array, int index)
        {
            if (array == null)
            {
                throw ExceptionBuilder.ArgumentNull("array");
            }
            if (index < 0)
            {
                throw ExceptionBuilder.ArgumentOutOfRange("index");
            }
            if ((array.Length - index) < this.list.Count)
            {
                throw ExceptionBuilder.InvalidOffsetLength();
            }
            for (int i = 0; i < this.list.Count; i++)
            {
                array[index + i] = (Constraint) this.list[i];
            }
        }

        internal Constraint FindConstraint(Constraint constraint)
        {
            int count = this.List.Count;
            for (int i = 0; i < count; i++)
            {
                if (((Constraint) this.List[i]).Equals(constraint))
                {
                    return (Constraint) this.List[i];
                }
            }
            return null;
        }

        internal ForeignKeyConstraint FindForeignKeyConstraint(DataColumn[] parentColumns, DataColumn[] childColumns)
        {
            int count = this.List.Count;
            for (int i = 0; i < count; i++)
            {
                ForeignKeyConstraint constraint = this.List[i] as ForeignKeyConstraint;
                if (((constraint != null) && CompareArrays(constraint.ParentKey.ColumnsReference, parentColumns)) && CompareArrays(constraint.ChildKey.ColumnsReference, childColumns))
                {
                    return constraint;
                }
            }
            return null;
        }

        internal UniqueConstraint FindKeyConstraint(DataColumn[] columns)
        {
            int count = this.List.Count;
            for (int i = 0; i < count; i++)
            {
                UniqueConstraint constraint = this.List[i] as UniqueConstraint;
                if ((constraint != null) && CompareArrays(constraint.Key.ColumnsReference, columns))
                {
                    return constraint;
                }
            }
            return null;
        }

        internal UniqueConstraint FindKeyConstraint(DataColumn column)
        {
            int count = this.List.Count;
            for (int i = 0; i < count; i++)
            {
                UniqueConstraint constraint = this.List[i] as UniqueConstraint;
                if (((constraint != null) && (constraint.Key.ColumnsReference.Length == 1)) && (constraint.Key.ColumnsReference[0] == column))
                {
                    return constraint;
                }
            }
            return null;
        }

        internal void FinishInitConstraints()
        {
            if (this.delayLoadingConstraints != null)
            {
                for (int i = 0; i < this.delayLoadingConstraints.Length; i++)
                {
                    DataColumn[] columnArray;
                    int length;
                    if (this.delayLoadingConstraints[i] is UniqueConstraint)
                    {
                        if (!this.fLoadForeignKeyConstraintsOnly)
                        {
                            UniqueConstraint constraint2 = (UniqueConstraint) this.delayLoadingConstraints[i];
                            if (constraint2.columnNames == null)
                            {
                                this.Add(constraint2);
                            }
                            else
                            {
                                length = constraint2.columnNames.Length;
                                columnArray = new DataColumn[length];
                                for (int j = 0; j < length; j++)
                                {
                                    columnArray[j] = this.table.Columns[constraint2.columnNames[j]];
                                }
                                if (constraint2.bPrimaryKey)
                                {
                                    if (this.table.primaryKey != null)
                                    {
                                        throw ExceptionBuilder.AddPrimaryKeyConstraint();
                                    }
                                    this.Add(constraint2.ConstraintName, columnArray, true);
                                }
                                else
                                {
                                    UniqueConstraint constraint4 = new UniqueConstraint(constraint2.constraintName, columnArray);
                                    if (this.FindConstraint(constraint4) == null)
                                    {
                                        this.Add(constraint4);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        ForeignKeyConstraint constraint = (ForeignKeyConstraint) this.delayLoadingConstraints[i];
                        if ((constraint.parentColumnNames == null) || (constraint.childColumnNames == null))
                        {
                            this.Add(constraint);
                        }
                        else if (this.table.DataSet == null)
                        {
                            this.fLoadForeignKeyConstraintsOnly = true;
                        }
                        else
                        {
                            length = constraint.parentColumnNames.Length;
                            columnArray = new DataColumn[length];
                            DataColumn[] childColumns = new DataColumn[length];
                            for (int k = 0; k < length; k++)
                            {
                                if (constraint.parentTableNamespace == null)
                                {
                                    columnArray[k] = this.table.DataSet.Tables[constraint.parentTableName].Columns[constraint.parentColumnNames[k]];
                                }
                                else
                                {
                                    columnArray[k] = this.table.DataSet.Tables[constraint.parentTableName, constraint.parentTableNamespace].Columns[constraint.parentColumnNames[k]];
                                }
                                childColumns[k] = this.table.Columns[constraint.childColumnNames[k]];
                            }
                            ForeignKeyConstraint constraint3 = new ForeignKeyConstraint(constraint.constraintName, columnArray, childColumns) {
                                AcceptRejectRule = constraint.acceptRejectRule,
                                DeleteRule = constraint.deleteRule,
                                UpdateRule = constraint.updateRule
                            };
                            this.Add(constraint3);
                        }
                    }
                }
                if (!this.fLoadForeignKeyConstraintsOnly)
                {
                    this.delayLoadingConstraints = null;
                }
            }
        }

        public int IndexOf(Constraint constraint)
        {
            if (constraint != null)
            {
                int count = this.Count;
                for (int i = 0; i < count; i++)
                {
                    if (constraint == ((Constraint) this.List[i]))
                    {
                        return i;
                    }
                }
            }
            return -1;
        }

        public int IndexOf(string constraintName)
        {
            int num = this.InternalIndexOf(constraintName);
            if (num >= 0)
            {
                return num;
            }
            return -1;
        }

        internal int InternalIndexOf(string constraintName)
        {
            int num3 = -1;
            if ((constraintName != null) && (0 < constraintName.Length))
            {
                int count = this.List.Count;
                for (int i = 0; i < count; i++)
                {
                    Constraint constraint = (Constraint) this.List[i];
                    switch (base.NamesEqual(constraint.ConstraintName, constraintName, false, this.table.Locale))
                    {
                        case 1:
                            return i;

                        case -1:
                            num3 = (num3 == -1) ? i : -2;
                            break;
                    }
                }
            }
            return num3;
        }

        private string MakeName(int index)
        {
            if (1 == index)
            {
                return "Constraint1";
            }
            return ("Constraint" + index.ToString(CultureInfo.InvariantCulture));
        }

        private void OnCollectionChanged(CollectionChangeEventArgs ccevent)
        {
            if (this.onCollectionChanged != null)
            {
                this.onCollectionChanged(this, ccevent);
            }
        }

        internal void RegisterName(string name)
        {
            int count = this.List.Count;
            for (int i = 0; i < count; i++)
            {
                if (base.NamesEqual(name, ((Constraint) this.List[i]).ConstraintName, true, this.table.Locale) != 0)
                {
                    throw ExceptionBuilder.DuplicateConstraintName(((Constraint) this.List[i]).ConstraintName);
                }
            }
            if (base.NamesEqual(name, this.MakeName(this.defaultNameIndex), true, this.table.Locale) != 0)
            {
                this.defaultNameIndex++;
            }
        }

        public void Remove(Constraint constraint)
        {
            if (constraint == null)
            {
                throw ExceptionBuilder.ArgumentNull("constraint");
            }
            if (this.CanRemove(constraint, true))
            {
                this.BaseRemove(constraint);
                this.ArrayRemove(constraint);
                if ((constraint is UniqueConstraint) && ((UniqueConstraint) constraint).IsPrimaryKey)
                {
                    this.Table.PrimaryKey = null;
                }
                this.OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, constraint));
            }
        }

        public void Remove(string name)
        {
            Constraint constraint = this[name];
            if (constraint == null)
            {
                throw ExceptionBuilder.ConstraintNotInTheTable(name);
            }
            this.Remove(constraint);
        }

        public void RemoveAt(int index)
        {
            Constraint constraint = this[index];
            if (constraint == null)
            {
                throw ExceptionBuilder.ConstraintOutOfRange(index);
            }
            this.Remove(constraint);
        }

        internal void UnregisterName(string name)
        {
            if (base.NamesEqual(name, this.MakeName(this.defaultNameIndex - 1), true, this.table.Locale) != 0)
            {
                do
                {
                    this.defaultNameIndex--;
                }
                while ((this.defaultNameIndex > 1) && !this.Contains(this.MakeName(this.defaultNameIndex - 1)));
            }
        }

        public Constraint this[int index]
        {
            get
            {
                if ((index < 0) || (index >= this.List.Count))
                {
                    throw ExceptionBuilder.ConstraintOutOfRange(index);
                }
                return (Constraint) this.List[index];
            }
        }

        public Constraint this[string name]
        {
            get
            {
                int num = this.InternalIndexOf(name);
                if (num == -2)
                {
                    throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
                }
                if (num >= 0)
                {
                    return (Constraint) this.List[num];
                }
                return null;
            }
        }

        protected override ArrayList List =>
            this.list;

        internal DataTable Table =>
            this.table;
    }
}

